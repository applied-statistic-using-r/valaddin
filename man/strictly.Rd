% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/strictly.R
\name{strictly}
\alias{is_strict_closure}
\alias{nonstrictly}
\alias{strict_body}
\alias{strict_check}
\alias{strict_reqarg}
\alias{strictly}
\title{Add input validation to a function}
\usage{
is_strict_closure(x)

strict_body(x)

strict_check(x)

strict_reqarg(x)

strictly(.f, ..., .checklist = list(), .warn_missing = FALSE)

nonstrictly(..f)
}
\arguments{
\item{x}{R object.}

\item{.f}{Interpreted function (i.e., closure), not a primitive function.}

\item{...}{Formulae, or single list thereof, that specify the argument checks
for \code{.f}.}

\item{..f}{Strict function, i.e., function of class \code{"strict_closure"}.}

\item{.cond}{Condition object (class \code{"condition"}) to be signaled if
any of the checks fail. If \code{.cond} is \code{NULL}, the default error
handler is used.}

\item{.chk_missing}{Logical. Should we check whether any required arguments
are missing? ("Required" arguments are explicit arguments without default
values; since they are promises, they need not be evaluated in the function
body.)}
}
\description{
A common form of boilerplate code at the top of functions is argument
checking: You make some checks on the arguments, signal a condition if any
show-stopping checks fail, then move on to the meat of the function if
everything is good. The problem with this approach is that it can clutter up
the main work of a function with admin---it spoils the "fun" of a function
with the inconvenience of a security check. The function \code{strictly()}
alleviates this nuissance by allowing you to enhance an existing function
with input validation, by using formulas to specify the checks.
}
\section{Attributes of a strict closure}{

  A strict closure stores properties of the function it "strictifies" as
  attributes: the function body, the checks, the condition, and the required
  arguments (if the strict closure is mandated to check their absence). The
  functions \code{strict_*()} are helper functions to extract these
  attributes.

  The predicate function \code{is_strict_closure()} is a reasonably stringent
  test of whether an object is a value of the function \code{strictly()}.
}

\section{Specifying argument checks}{

  An argument check is specified by a formula whose interpretation depends on
  whether it is one- or two-sided:
  \itemize{
    \item One-sided formula \code{~p}: reads "For every argument for which
      \code{p} fails, stop with a message of this failure." For example, the
      formula \code{~is.numeric} enforces a check for all arguments to be
      numerical.
    \item Two-sided formula \code{q ~ p}: reads "Stop with the message
      \code{q}, if the check \code{p} fails." For example, the "logicalness"
      of the \code{.chk_missing} argument of \code{strictly}, itself, is
      enforced by the formula \code{"Not logical: `.chk_missing`" ~
      purrr::is_scalar_logical(.chk_missing)}.
  }

  More precisely, for a one-sided formula \code{~p}, the expression \code{p}
  is a predicate function which is applied to each argument of \code{.f}; for
  a two-side formula \code{q ~ p}, \code{q} is an expression whose evaluation
  yields a string---the "failure message"---while \code{p} is an expression
  that is a call to a predicate function---the "check". (In particular, the
  evaluation of \code{p} must always yield either \code{TRUE} or
  \code{FALSE}.) A message generated by a failing check becomes part of the
  total message of the condition \code{.cond}.

  A two-sided formula check is most useful when one needs to exercise special
  control of a specific argument, or needs to express a more complicated
  check involving several arguments, e.g., \code{"Invalid range" ~ (0 < a) &&
  (a <= b) && (b <= c)}, specifies that (the arguments) \code{a}, \code{b},
  \code{c} must be a monotonically increasing sequence of positive numbers. A
  one-sided formula check is simply a handy shorthand for submitting each and
  every argument to a common check.
}
\examples{
foo <- function(x, y, a = "sum:", ...) paste(a, x + y)
foo(1, 2)                     # "sum: 3"
foo(1, 2, "SUM:")             # "SUM: 3"
foo(1, 2, "SUM:", bogus_obj)  # "SUM: 3" (arguments are evaluated lazily)

foo_strict <- strictly(foo)
foo_strict(1, 2)                     # "sum: 3"
foo_strict(1, 2, "SUM:")             # "SUM: 3"
foo_strict(1, 2, "SUM:", bogus_obj)  # "SUM: 3"

# `foo` and `foo_strict` have the same parent environment
identical(parent.env(environment(foo)), parent.env(environment(foo_strict)))
# `environment(foo_strict)` has the bindings of `environment(foo)`, at the
# point where `foo_strict` is defined
e <- setdiff(names(environment(foo)), "foo_strict")
identical(sort(names(environment(foo_strict))), sort(e))

foo_stricter <- strictly(foo_strict,
                         "Not numeric" ~ is.numeric(x) && is.numeric(y))
foo_stricter(1, 2)                     # "sum: 3"
foo_stricter(1, 2, "SUM:", bogus_obj)  # "SUM: 3"
foo_stricter(1, "2")                   # Error: Not numeric
foo_stricter(1, 2, NA_real_)           # "NA 3"

foo_strictest <- strictly(foo_stricter,
                          "Not string" ~ purrr::is_scalar_character(a),
                          .chk_missing = TRUE)
foo_strictest(1, 2)            # "sum: 3"
foo_strictest(1, "2")          # Error: Not numeric
foo_strictest(1, 2, NA_real_)  # Error: Not string
foo_strictest(1, a = "foo")    # Error: Missing required arguments: y

bar <- function(x, y) x - y
is_positive <- function(x) x >= 0
bar_strict <- strictly(bar, ~is.numeric, ~is_positive)
bar_strict(1, 2)        # -1
bar_strict(1, -2)       # is_positive(.) is FALSE: `y`
bar_strict("1", 2)      # is.numeric(.) is FALSE: `x`
bar_strict("1", "two")  # is.numeric(.) is FALSE: `x`, `y`

# Multiple failures are captured in the error message
bar_strict("1", -2)
# is.numeric(.) is FALSE: `x`; is_positive(.) is FALSE: `y`
}

