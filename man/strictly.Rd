% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/strictly.R
\name{strictly}
\alias{nonstrictly}
\alias{strictly}
\title{Apply a function strictly}
\usage{
strictly(.f, ..., .checklist = list(), .warn_missing = NULL)

nonstrictly(.f)
}
\arguments{
\item{.f}{Interpreted function, i.e., closure (not a primitive function).}

\item{...}{Check formulae.}

\item{.checklist}{List of check formulae.}

\item{.warn_missing}{Logical or \code{NULL}. Should the absence of required
arguments be checked? ("Required" arguments are those without default
value.) This question is disregarded when \code{.warn_missing} is
\code{NULL}.}
}
\description{
\code{strictly()} hardens a function with input validation, using formulae to
specify checks. It modifies a function to respond more consistently to
errors, and is therefore an adverb, like the purrr functions
\code{\link[purrr]{safely}()} and \code{\link[purrr]{possibly}()}. The
process of making a function strict can be undone using \code{nonstrictly()}.
}
\section{Specifying argument checks}{

  An argument check is specified by a formula whose interpretation depends on
  whether it is one- or two-sided:
  \itemize{
    \item One-sided formula \code{~p}: reads "For every argument for which
      \code{p} fails, stop with a message of this failure." For example, the
      formula \code{~is.numeric} enforces a check for all arguments to be
      numerical.
    \item Two-sided formula \code{q ~ p}: reads "Stop with the message
      \code{q}, if the check \code{p} fails." For example, the "logicalness"
      of the \code{.chk_missing} argument of \code{strictly}, itself, is
      enforced by the formula \code{"Not logical: `.chk_missing`" ~
      purrr::is_scalar_logical(.chk_missing)}.
  }

  More precisely, for a one-sided formula \code{~p}, the expression \code{p}
  is a predicate function which is applied to each argument of \code{.f}; for
  a two-side formula \code{q ~ p}, \code{q} is an expression whose evaluation
  yields a string---the "failure message"---while \code{p} is an expression
  that is a call to a predicate function---the "check". (In particular, the
  evaluation of \code{p} must always yield either \code{TRUE} or
  \code{FALSE}.) A message generated by a failing check becomes part of the
  total message of the condition \code{.cond}.

  A two-sided formula check is most useful when one needs to exercise special
  control of a specific argument, or needs to express a more complicated
  check involving several arguments, e.g., \code{"Invalid range" ~ (0 < a) &&
  (a <= b) && (b <= c)}, specifies that (the arguments) \code{a}, \code{b},
  \code{c} must be a monotonically increasing sequence of positive numbers. A
  one-sided formula check is simply a handy shorthand for submitting each and
  every argument to a common check.
}
\examples{
foo <- function(x, y, a = "sum:", ...) paste(a, x + y)
foo(1, 2)                     # "sum: 3"
foo(1, 2, "SUM:")             # "SUM: 3"
foo(1, 2, "SUM:", bogus_obj)  # "SUM: 3" (arguments are evaluated lazily)

foo_strict <- strictly(foo)
identical(foo, foo_strict)

foo_stricter <- strictly(foo_strict, list(~x, ~y) ~ is.numeric)
foo_stricter(1, 2)                     # "sum: 3"
foo_stricter(1, 2, "SUM:", bogus_obj)  # "SUM: 3"
foo_stricter(1, "2")                   # FALSE: is.numeric(y)
foo_stricter(1, 2, NA_real_)           # "NA 3"

# `foo` and `foo_stricter` share the same environment
identical(environment(foo), environment(foo_stricter))

# `foo_stricter` preserves the attributes of `foo`
all(attributes(foo) \%in\% attributes(foo_stricter))

foo_strictest <- strictly(
  foo_stricter,
  list("Not string" ~ a) ~ purrr::is_scalar_character,
  .warn_missing = TRUE
)
foo_strictest(1, 2)            # "sum: 3"
foo_strictest(1, "2")          # FALSE: is.numeric(y)
foo_strictest(1, 2, NA_real_)  # Not string
foo_strictest(1, a = "foo")    # Error evaluating check, missing argument

g <- function(x, y) x - y
g_sct <- strictly(bar, ~is.numeric, ~{. > 0})
g_sct(1, 2)        # -1
g_sct(1, -2)       # FALSE: (purrr::as_function(~{. > 0}))(y)
g_sct("1", 2)      # FALSE: is.numeric(x)
g_sct("1", "two")  # FALSE: is.numeric(x), is.numeric(y)
g_sct("1", -2)     # FALSE: is.numeric(x), (purrr::as_function(~{. > 0}))(y)

h <- strictly(
  function(x, y) log(x - y),
  "Not numeric" ~ is.numeric,
  list(~y, "`x` not greater than `y`" ~ x - y) ~ {. > 0}
)
h(4, 2)    # 0.6931472
h(3, 0)    # FALSE: (purrr::as_function(~{. > 0}))(y)
h(3, 3)    # `x` not greater than `y`
h("4", 1)  # Not numeric: `x`, error evaluating check
}

