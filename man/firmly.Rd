% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/firmly.R
\name{firmly}
\alias{firmly}
\alias{loosely}
\alias{is_firm}
\title{Apply a function firmly}
\arguments{
\item{.f}{Interpreted function, i.e., a function of type \code{"closure"}.}

\item{\dots}{Check formula(e) (see \emph{Check Formulae}).}

\item{.checklist}{List of check formulae. These are combined with check
formulae provided via \code{\dots}.}

\item{.warn_missing}{Character vector of arguments of \code{.f} whose absence
should raise a warning.}

\item{.keep_check, .keep_warning}{\code{TRUE} or \code{FALSE}: Should existing
checks, resp. missing-argument warnings, be kept?}

\item{.quiet}{\code{TRUE} or \code{FALSE}: Should a warning that \code{.f} is
not a firmly applied function be muffled?}

\item{x}{Object to test.}
}
\description{
\code{firmly} transforms a function into a function with input validation
checks. \code{loosely} undoes the application of \code{firmly}, by returning
the original function, without checks. \code{is_firm} is a predicate function
that checks whether an object is a firmly applied function, i.e., one created
by \code{firmly}.
}
\section{Check Formulae}{

  An \strong{input validation check} is specified by a \strong{check
  formula}, a special \link[stats]{formula} of the form
  \preformatted{<scope> ~ <predicate>}
  where the right-hand side expresses \emph{what} to check, and the left-hand
  side expresses \emph{where} to check it.

  The right-hand side \code{<predicate>} is a \strong{predicate} function,
  i.e, a one-argument function that returns either \code{TRUE} or
  \code{FALSE}. It is the condition to check/enforce. The left-hand side
  \code{<scope>} is an expression specifying what the condition is to be
  applied to: whether the condition is to be applied to all \emph{named}
  arguments of \code{.f} (the case of \dQuote{global scope}), or whether the
  condition is to be selectively applied to certain expressions of the
  arguments (the case of \dQuote{local scope}).

  Thus according to \strong{scope}, there are two classes of check formulae:
  \itemize{
    \item \strong{Check formulae of global scope}
      \preformatted{<string> ~ <predicate>}
      \preformatted{~ <predicate>}

    \item \strong{Check formulae of local scope}
      \preformatted{list(<check_item>, <check_item>, ...) ~ <predicate>}
  }

  \subsection{Check formulae of global scope}{
    A \strong{global check formula} is a succinct way of enforcing the
    veracity of the function \code{<predicate>} upon every (named) argument
    of \code{.f}. Each argument for which \code{<predicate>}
    \emph{fails}—evaluates to \code{FALSE} or is itself not
    evaluable—produces an error message, which is auto-generated, unless a
    custom error message is supplied by specifying the string
    \code{<string>}.

    \subsection{Example}{
      The condition that all (named) arguments of a function must be
      numerical can be enforced by the check formula
      \preformatted{~ is.numeric}
      or
      \preformatted{"Not numeric" ~ is.numeric}
      if the custom error message \code{"Not numeric"} is to be used (in lieu
      of an auto-generated error message).
    }
  }

  \subsection{Check formulae of local scope}{
    A \strong{local check formula} imposes argument-specific conditions. Each
    \strong{check item} \code{<check_item>} is a formula of the form \code{~
    <expression>} (one-sided) or \code{<string> ~ <expression>}; it imposes
    the condition that the function \code{<predicate>} is \code{TRUE} for the
    expression \code{<expression>}. As for global check formulae, each check
    item for which \code{<predicate>} fails produces an error message, which
    is auto-generated, unless a custom error message is supplied by a string
    as part of the left-hand side of the check item (formula).

    \subsection{Example}{
      The condition that \code{x} and \code{y} must differ for the function
      \code{function(x, y) \{1 / (x - y)\}} can be enforced by the local
      check formula
      \preformatted{list(~ x - y) ~ function(.) abs(.) > 0}
      or
      \preformatted{list("x, y must differ" ~ x - y) ~ function(.) abs(.) > 0}
      if the custom error message \code{"x, y must differ"} is to be used (in
      lieu of an auto-generated error message).
    }
  }

  \subsection{Anonymous predicate functions}{
    Following the
    \href{https://cran.r-project.org/package=magrittr}{\pkg{magrittr}}
    package, an anonymous (predicate) function of a single argument \code{.}
    can be concisely expressed by enclosing the body of such a function
    within curly braces \code{\{ \}}.

    \subsection{Example}{
      The (onsided, global) check formula
      \preformatted{~ {. > 0}}
      is equivalent to the check formula \code{~ function(.) {. > 0}}
    }
  }
}

\section{Value}{

  \subsection{\code{firmly}}{
    \code{firmly} does nothing when there is nothing to do: \code{.f} is
    returned, unaltered, when both \code{.checklist} and
    \code{.warn_missing} are empty, or when \code{.f} has no named argument
    and \code{.warn_missing} is empty.

    Otherwise, \code{firmly} again returns a function that behaves
    \emph{identically} to \code{.f}, with the exception that it validates its
    inputs before being called on them. In particular, \code{firmly} respects
    lazy evaluation: if all checks pass, then when \code{.f} is called, all
    arguments, including those that underwent checks, are lazily evaluated.

    If any check fails, an error is signaled, which tabulates every failing
    check.

    \subsection{Formal Arguments and Attributes}{
      \code{firmly} preserves the formal arguments of \code{.f}, along with
      its attributes (except that the \code{"class"} attribute gains the
      component \code{"firm_closure"}, unless it already contains it).
    }
  }

  \subsection{\code{loosely}}{
    \code{loosely} returns \code{.f}, unaltered, when \code{.f} is not a
    firmly applied function, or both \code{.keep_check} and
    \code{.keep_warning} are \code{TRUE}.

    Otherwise, \code{loosely} returns the underlying (original) function,
    stripped of any input validation checks imposed by \code{firmly}, unless
    \code{.keep_check} or \code{.keep_warning} overrides this: if
    \code{.keep_check}, resp. \code{.keep_warning}, is \code{TRUE},
    \code{loosely} retains any existing checks, resp. missing-argument
    warnings.
  }
}

\examples{
\dontrun{

secant <- function(f, x, dx) (f(x + dx) - f(x)) / dx

# Ensure that `f` is a function
secant_firm <- firmly(secant, list("`f` not a function" ~ f) ~ is.function)
secant_firm(log, 1, .1)    # 0.9531018
secant_firm("log", 1, .1)  # Error: "`f` not a function"

# Ensure that `x` and `dx` are numerical (possibly non-scalars)
secant_vec <- firmly(secant_firm, list(~x, ~dx) ~ is.numeric)
secant_vec(log, c(1, 2), .1)  # 0.9531018 0.4879016
secant_vec("log", 1, .1)      # Error: "`f` not a function" (as before)
secant_vec(log, "1", .1)      # Error: "FALSE: is.numeric(x)"
secant_vec("log", "1", .1)    # Two errors

# Ensure that `dx` is a numerical scalar
secant_scalar <- firmly(secant_firm, list(~dx) ~ purrr::is_scalar_numeric)
secant_scalar(log, c(1, 2), .1)    # 0.9531018 0.4879016 (as before)
secant_scalar(log, 1, c(.1, .05))  # Error: "FALSE: purrr::is_scalar_numeric(dx)"
secant_scalar(log, 1, ".1" / 2)    # Error evaluating check

# Use purrr::lift() for predicate functions with multi-argument dependencies
f <- function(f, l, r) secant(f, l, dx = r - l)
is_monotone <- function(x, y) y - x > 0
secant_right <- firmly(f, list(~list(l, r)) ~ purrr::lift(is_monotone))
secant_right(log, 1, 1.1)  # 0.9531018
secant_right(log, 1, .9)   # Error: "FALSE: purrr::lift(is_monotone)(list(l, r))"

# Alternatively, secant_right() can be implemented with a unary check
secant_right2 <- firmly(f, list(~ r - l) ~ {. > 0})
all.equal(secant_right(log, 1, 1.1), secant_right2(log, 1, 1.1))  # TRUE
secant_right2(log, 1, .9)  # Error (as before)

# firmly won't force any argument not involved in a check
g <- firmly(function(x, y) "Pass", list(~x) ~ is.character)
g(c("a", "b"), stop("Not signaled"))  # "Pass"

# loosely recovers the underlying function
identical(loosely(secant_vec), secant)  # TRUE
}

}
\seealso{
\link{scope-changing}, \link{checklist}, \link{components},
  \link{bare-type-checkers}, \link{scalar-type-checkers},
  \link{type-checkers}, \link{misc-checkers}
}
\usage{
firmly(.f, ..., .checklist = list(), .warn_missing = character())

loosely(.f, .keep_check = FALSE, .keep_warning = FALSE, .quiet = TRUE)

is_firm(x)
}
