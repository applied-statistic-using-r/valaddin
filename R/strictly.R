#' @include utils.R
NULL

unfurl_args <- function(.lhs, .arg_nm, .arg_symb, .env) {
  q <- lapply(.arg_symb, lazyeval::f_new, env = .env)
  if (!is.null(.lhs)) {
    names(q) <- paste(.lhs, encodeString(.arg_nm, quote = "`"), sep = ": ")
  } else {
    names(q) <- character(length(q))
  }

  q
}

lambda <- function(p, env) {
  purrr::as_function(lazyeval::f_new(p, env = env))
}

expr_lambda <- function(body) {
  call("function", pairlist(. = substitute()), body)
}

assemble <- function(.chk, .nm, .symb, .env = lazyeval::f_env(.chk)) {
  p <- lazyeval::f_rhs(.chk)
  if (is_lambda(p)) {
    predicate <- lambda(p, .env)
    p_symb    <- expr_lambda(p)
  } else {
    predicate <- lazyeval::f_eval_rhs(.chk)
    p_symb    <- p
  }

  lhs <- lazyeval::f_eval_lhs(.chk)
  q <- if (is.list(lhs)) {
    do.call(lazyeval::f_list, lhs)
  } else {
    unfurl_args(lhs, .nm, .symb, .env)
  }
  string <- purrr::map_chr(q, function(.)
    sprintf(string_funexpr(p_symb), deparse_collapse(lazyeval::f_rhs(.)))
  )
  is_empty <- names(q) == ""
  names(q)[is_empty] <- sprintf("FALSE: %s", string[is_empty])

  purrr::pmap_df(list(q, string, names(q)), function(x, s, m) {
    dplyr::data_frame(
      expr   = list(as.call(c(predicate, lazyeval::f_rhs(x)))),
      string = s,
      msg    = m
    )
  })
}

warn <- function(.ref_args) {
  force(.ref_args)

  function(.call) {
    missing <- setdiff(.ref_args, names(.call[-1L]))

    if (length(missing)) {
      msg <- missing %>%
        paste(collapse = ", ") %>%
        sprintf("Missing required argument(s): %s", .)
      warning(msg, call. = FALSE)
    }

    invisible(.call)
  }
}

warning_closure <- function(.fn, .warn) {
  function() {
    call <- match.call()
    parent <- parent.frame()

    .warn(call)

    eval(.fn(call), parent, parent)
  }
}

report_error <- function(.expr, .string, .msg, .env) {
  tryCatch(
    {
      val <- suppressWarnings(eval(.expr, .env, .env))

      if (is_true(val))
        NA_character_
      else if (is_false(val))
        .msg
      else
        sprintf("Predicate value %s neither TRUE nor FALSE: %s",
                .string, deparse_collapse(val))
    },
    error = function(e)
      sprintf("Error evaluating check %s: %s", .string, e$message)
  )
}

validating_closure <- function(.chks, .args, .fn, .warn) {
  function() {
    call <- match.call()

    .warn(call)

    promises <- do.call(lazyeval::lazy_dots, .args)
    parent <- parent.frame()
    env <- lazy_assign(promises, new.env(parent = parent))

    # unlist(Map()) is somewhat faster than purrr::pmap_chr()
    .chks$msg <- unlist(Map(function(e, s, m) report_error(e, s, m, env),
                            .chks$expr, .chks$string, .chks$msg))
    is_problematic <- !is.na(.chks$msg)

    if (any(is_problematic)) {
      msg_call  <- sprintf("%s\n", deparse_collapse(call))
      msg_error <- enumerate_many(.chks[is_problematic, ]$msg)
      stop(paste0(msg_call, msg_error), call. = FALSE)
    } else {
      eval(.fn(call), parent, parent)
    }
  }
}

is_void_symb <- function(x) {
  is.symbol(x) && x == substitute()
}

#' Represent non-dot arguments by name and symbol
#'
#' @param sig Pairlist.
#' @return List with components \code{"nm"} (character), \code{"symb"} (symbol),
#'   \code{"wo_value"} (logical).
#' @keywords internal
nomen <- function(sig) {
  nm <- setdiff(names(sig), "...") %||% character(0)
  list(
    nm       = nm,
    symb     = lapply(nm, as.symbol),
    wo_value = vapply(sig[nm], is_void_symb, logical(1), USE.NAMES = FALSE)
  )
}

strict_closure <- function(.f) {
  structure(.f, class = c("strict_closure", class(.f)))
}

checks <- list(
  list("`.f` not an interpreted function" ~ .f) ~
    purrr::is_function,
  list("`.warn_missing` neither NULL nor logical scalar" ~ .warn_missing) ~
  {is.null(.) || purrr::is_scalar_logical(.) && !is.na(.)}
)

strictly_ <- function(.f, ..., .checklist = list(), .warn_missing = NULL) {
  chks <- c(list(...), .checklist)

  if (!is_checklist(chks)) {
    stop("Invalid argument checks", call. = FALSE)
  }

  sig <- formals(.f)
  arg <- nomen(sig)

  is_some_check <-
    length(chks) && length(arg$nm) ||
    !is.null(.warn_missing) && any(arg$wo_value)
  if (!is_some_check) {
    return(.f)
  }

  is_missing <-
    is_true(.warn_missing) ||
    is.null(.warn_missing) && !is.null(strict_args(.f))
  maybe_warn <- if (is_missing) warn(arg$nm[arg$wo_value]) else invisible
  f_core <- if (is_strict_closure(.f)) strict_core(.f) else .f
  fn <- call_fn(f_core)
  pre_chks <- strict_checks(.f)

  if (!length(chks)) {  # .warn_missing is either TRUE or FALSE
    if (is.null(pre_chks) && is_false(.warn_missing))
      return(f_core)

    f <- if (is.null(pre_chks))
      warning_closure(fn, maybe_warn)
    else
      validating_closure(pre_chks, arg$symb, fn, maybe_warn)
  } else {
    assembled_chks <- dplyr::distinct(
      dplyr::bind_rows(pre_chks,
                       lapply(chks, assemble, .nm = arg$nm, .symb = arg$symb))
    )
    f <- validating_closure(assembled_chks, arg$symb, fn, maybe_warn)
  }

  strict_closure(with_sig(f, sig, .attrs = attributes(.f)))
}

#' Apply a function strictly
#'
#' \code{strictly()} transforms a function to a function with input validation
#' checks. \code{nonstrictly()} undoes the application of \code{strictly()}, by
#' returning the original function, without checks.
#'
#' @return \code{strictly()} returns the function \code{.f} unchanged, if
#'   neither \code{.warn_missing} nor the check formula(e) are applicable to
#'   \code{.f}; otherwise, a function of class \code{"strict_closure"} is
#'   returned. The argument signature, environment, and attributes of \code{.f}
#'   are preserved.\cr\cr
#'   \code{nonstrictly()} returns the original function without checks.
#' @name strictly
NULL

#' @rdname strictly
#' @export
#' @param .f Interpreted function, i.e., function of type \code{"closure"}.
#' @param ... Check formula(e); see "Details".
#' @param .checklist List of check formulae.
#' @param .warn_missing \code{TRUE} or \code{FALSE}: Should the absence of
#'   required arguments be checked? (A "required argument" is a (named) argument
#'   without default value.) This question is disregarded if
#'   \code{.warn_missing} is \code{NULL}.
#' @details Input validation checks are specified by formulae conforming to one
#'   of two types:
#'   \itemize{
#'     \item \strong{Global check formulae}:\cr
#'       \code{~ <predicate>} (onesided),\cr
#'       \code{<string> ~ <predicate>}
#'     \item \strong{Local check formulae}:\cr
#'       \code{list(<check_item>, <check_item>, ...) ~ <predicate>}
#'   }
#'   where \code{<predicate>} is a predicate function of a single argument,
#'   i.e., a function that returns either \code{TRUE} or \code{FALSE}.
#'   \cr\cr
#'   A \emph{global check formula} asserts that the evaluation of
#'   \code{<predicate>} is \code{TRUE} for each (named) argument of \code{.f}.
#'   Each argument for which the \code{<predicate>} fails (i.e., evaluates to
#'   \code{FALSE}) produces an error message, which is auto-generated unless a
#'   custom error message is supplied by specifying the string \code{<string>}.
#'   \cr\cr
#'   Example: the assertion that all (named) arguments of a function must be
#'   numerical can be enforced by the check formula \code{~ is.numeric}, or
#'   \code{"Not numeric" ~ is.numeric}, if the custom error message \code{"Not
#'   numeric"} is to be used.
#'   \cr\cr
#'   A \emph{local check formula} makes argument-specific assertions. Each
#'   "check item" \code{<check_item>} is a formula of the form \code{~
#'   <expression>} (onesided) or \code{<string> ~ <expression>}; it makes the
#'   assertion that the \code{<predicate>} evaluates to \code{TRUE} for the
#'   expression \code{<expression>}. As for global check formulae, each check
#'   item for which the \code{<predicate>} fails produces an error message,
#'   which is auto-generated unless a custom error message is supplied by a
#'   string as part of the left-hand side of the check item (formula).
#'   \cr\cr
#'   Example: the assertion that \code{x} and \code{y} must differ for the
#'   function \code{function(x, y) 1 / (x - y)} can be enforced by the local
#'   check formula \code{list(~ x - y) ~ function(.) abs(.) > 0}, or
#'   \code{list("x, y must differ" ~ x - y) ~ function(.) abs(.) > 0}, if the
#'   custom error message \code{"x, y must differ"} is to be used.
#'   \cr\cr
#'   Check formulae that are specified individually as part of the \code{...}
#'   argument of \code{strictly()} are combined with check formulae of the
#'   list-argument \code{.checklist}.
#' @examples
#'
strictly <- strictly_(strictly_, .checklist = checks, .warn_missing = TRUE)

nonstrictly_ <- function(.f, .quiet = FALSE) {
  if (is_strict_closure(.f)) {
    strict_core(.f)
  } else {
    if (!.quiet) {
      warning("Argument not a strictly applied function", call. = FALSE)
    }
    .f
  }
}

#' @rdname strictly
#' @export
#' @param quiet \code{TRUE} or \code{FALSE}: Should a warning be signaled if
#'   \code{.f} is not a strictly applied function?
nonstrictly <- strictly_(
  nonstrictly_,
  list("Argument not an interpreted function" ~ .f) ~ purrr::is_function,
  list("`.quiet` is not TRUE/FALSE" ~ .quiet) ~ {is_true(.) || is_false(.)}
)

#' @export
print.strict_closure <- function(x) {
  cat("<strict_closure>\n")

  cat("\n* Core function:\n")
  print(strict_core(x))

  cat("\n* Checks (<predicate>:<error message>):\n")
  calls <- strict_checks(x)
  if (!is.null(calls) && nrow(calls)) {
    labels <- paste0(calls$string, ":\n", encodeString(calls$msg, quote = "\""))
    cat(enumerate_many(labels))
  } else {
    cat("None\n")
  }

  cat("\n* Check for missing arguments:\n")
  args <- strict_args(x)
  if (!is.null(args) && length(args)) {
    cat(paste(args, collapse = ", "))
  } else {
    cat("Not checked\n")
  }
}
