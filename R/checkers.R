#' @include scope.R
NULL

scrub <- function(pttn_rm, pttn_sep) {
  force(pttn_rm)
  force(pttn_sep)

  function(x) gsub(pttn_sep, " ", gsub(pttn_rm, "", x))
}

localize_nm <- function(nm, what_is, ns, env) {
  msg <- paste("Not", what_is(nm))
  p <- getExportedValue(ns, nm)

  localize(f_new(p, msg, env = env))
}

make_vld_chkrs <- function(ns, pattern, sep, env = parent.frame()) {
  nms <- grep(pattern, getNamespaceExports(ns), value = TRUE)
  what_is <- scrub(pttn_rm = pattern, pttn_sep = sep)
  chkrs <- lapply(nms, localize_nm, ns = ns, what_is = what_is, env = env)
  names(chkrs) <- paste("vld", gsub(pattern, "", nms), sep = "_")

  chkrs[sort(names(chkrs))]
}

chkrs_purrr <- make_vld_chkrs("purrr", pattern = "^is_", sep = "_")
for (nm in names(chkrs_purrr))
  assign(nm, chkrs_purrr[[nm]])

#' @rawNamespace exportPattern("^vld_.*$")
NULL

# Documentation -----------------------------------------------------------

nms <- lapply(c(bare = "^vld_bare", scalar = "^vld_scalar"),
              grep, x = names(chkrs_purrr), value = TRUE)
nms$misc <- paste0("vld_", c("empty", "formula"))
nms$type <- setdiff(names(chkrs_purrr), unlist(nms))

#' Type checkers
#'
#' These functions make check formulae of local scope based on the
#' correspondingly named \link[purrr:type-predicates]{type predicate} from the
#' \pkg{purrr} package. For example, \code{vld_atomic()} creates check formulae
#' (of local scope) for the \pkg{purrr} predicate function
#' \code{\link[purrr]{is_atomic}()}.
#'
#' @evalRd rd_alias(nms$type)
#' @evalRd rd_usage(nms$type)
#' @param ... One-sided formulae that specify the expressions to check.
#' @return Check formula of local scope.
#' @details Each function \code{vld_*()} is a function of class
#'   \code{"check_maker"} generated by \code{\link{localize}()}.
#' @seealso \link[purrr:type-predicates]{Type predicates} (\pkg{purrr}),
#'   \code{\link{globalize}()} (recover the underlying check formula of global
#'   scope)
#' @family type checkers
#' @examples
#' \dontrun{
#'
#' f <- function(x, y) "Pass"
#'
#' # Impose a check on x: ensure it's of type "logical"
#' f_strict <- strictly(f, vld_logical(~ x))
#' f_strict(TRUE, 0)  # "Pass"
#' f_strict(1, 0)     # Error: "Not logical: x"
#'
#' # To impose the same check on all arguments, apply globalize()
#' f_stricter <- strictly(f, globalize(vld_logical))
#' f_stricter(TRUE, FALSE)  # "Pass"
#' f_stricter(TRUE, 0)      # Error: "Not logical: y"
#' f_stricter(1, 0)         # Errors: "Not logical: x", "Not logical: y"
#' }
#' @name type-checkers
NULL

#' Bare type checkers
#'
#' These functions make check formulae of local scope based on the
#' correspondingly named \link[purrr:bare-type-predicates]{bare type predicate}
#' from the \pkg{purrr} package. For example, \code{vld_bare_atomic()} creates
#' check formulae (of local scope) for the \pkg{purrr} predicate function
#' \code{\link[purrr]{is_bare_atomic}()}.
#'
#' @evalRd rd_alias(nms$bare)
#' @evalRd rd_usage(nms$bare)
#' @param ... One-sided formulae that specify the expressions to check.
#' @inherit type-checkers
#' @seealso \link[purrr:bare-type-predicates]{Bare type predicates}
#'   (\pkg{purrr}), \code{\link{globalize}()} (recover the underlying check
#'   formula of global scope)
#' @family type checkers
#' @examples
#' \dontrun{
#'
#' f <- function(x, y) "Pass"
#'
#' # Impose a check on x: ensure it's a bare logical object (i.e., has no class)
#' f_strict <- strictly(f, vld_bare_logical(~ x))
#' x <- structure(TRUE, class = "boolean")
#' f_strict(TRUE, 0)  # "Pass"
#' f_strict(x, 0)     # Error: "Not bare logical: x"
#'
#' # To impose the same check on all arguments, apply globalize()
#' f_stricter <- strictly(f, globalize(vld_bare_logical))
#' f_stricter(TRUE, FALSE)  # "Pass"
#' f_stricter(TRUE, 0)      # Error: "Not bare logical: y"
#' f_stricter(x, 0)         # Errors: "Not bare logical: x", "Not bare logical: y"
#' }
#' @name bare-type-checkers
NULL

#' Scalar type checkers
#'
#' These functions make check formulae of local scope based on the
#' correspondingly named \link[purrr:scalar-type-predicates]{scalar type
#' predicate} from the \pkg{purrr} package. For example,
#' \code{vld_scalar_atomic()} creates check formulae (of local scope) for the
#' \pkg{purrr} predicate function \code{\link[purrr]{is_scalar_atomic}()}.
#'
#' @evalRd rd_alias(nms$scalar)
#' @evalRd rd_usage(nms$scalar)
#' @param ... One-sided formulae that specify the expressions to check.
#' @inherit type-checkers
#' @seealso \link[purrr:scalar-type-predicates]{Scalar type predicates}
#'   (\pkg{purrr}), \code{\link{globalize}()} (recover the underlying check
#'   formula of global scope)
#' @family type checkers
#' @examples
#' \dontrun{
#'
#' f <- function(x, y) "Pass"
#'
#' # Impose a check on x: ensure it's a scalar logical vector
#' f_strict <- strictly(f, vld_scalar_logical(~ x))
#' f_strict(TRUE, 0)           # "Pass"
#' f_strict(c(TRUE, TRUE), 0)  # Error: "Not scalar logical: x"
#'
#' # To impose the same check on all arguments, apply globalize()
#' f_stricter <- strictly(f, globalize(vld_scalar_logical))
#' f_stricter(TRUE, FALSE)    # "Pass"
#' f_stricter(TRUE, 0)        # Error: "Not scalar logical: y"
#' f_stricter(logical(0), 0)  # Errors: "Not scalar logical: x", "Not scalar logical: y"
#' }
#' @name scalar-type-checkers
NULL

#' Miscellaneous type checkers
#'
#' These functions make check formulae of local scope based on the
#' correspondingly named predicates \code{\link[purrr]{is_empty}()},
#' \code{\link[purrr]{is_formula}()} from the \pkg{purrr} package.
#'
#' @evalRd rd_alias(nms$misc)
#' @evalRd rd_usage(nms$misc)
#' @param ... One-sided formulae that specify the expressions to check.
#' @inherit type-checkers
#' @seealso \code{\link[purrr]{is_empty}}, \code{\link[purrr]{is_formula}}
#'   (\pkg{purrr}); \code{\link{globalize}()} (recover the underlying check
#'   formula of global scope)
#' @family type checkers
#' @examples
#' \dontrun{
#'
#' f <- function(x, y) "Pass"
#'
#' # Impose the condition that x is a formula
#' g <- strictly(f, vld_formula(~ x))
#' g(z ~ a + b, 0)  # "Pass"
#' g(0, 0)          # Error: "Not formula: x"
#'
#' # Impose the condition that x and y are disjoint (assuming they are vectors)
#' h <- strictly(f, vld_empty(~ intersect(x, y)))
#' h(letters[1:3], letters[4:5])  # "Pass"
#' h(letters[1:3], letters[3:5])  # Error: "Not empty: intersect(x, y)"
#' }
#' @name misc-checkers
NULL
