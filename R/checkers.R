#' @include scope.R
NULL

localize_nm <- function(nm, what_is, ns, env) {
  msg <- paste("Not", what_is(nm))
  p <- getExportedValue(ns, nm)

  localize(f_new(p, msg, env = env))
}

replace <- function(x, pattern, with, ...) gsub(pattern, with, x, ...)
delete  <- function(x, pattern, ...) replace(x, pattern, "", ...)
scrub   <- function(pttn_rm, pttn_sep) {
  force(pttn_rm)
  force(pttn_sep)

  function(x)
    x %>% delete(pttn_rm) %>% replace(pttn_sep, with = " ")
}

make_vld_chkrs <- function(nms, pattern, sep, ns, env = parent.frame()) {
  what_is <- scrub(pttn_rm = pattern, pttn_sep = sep)
  chkrs <- lapply(nms, localize_nm, ns = ns, what_is = what_is, env = env)
  names(chkrs) <- nms %>%
    delete(pattern) %>%
    replace("\\.", with = "_") %>% {
      paste("vld", ., sep = "_")
    }

  chkrs[sort(names(chkrs))]
}

pkg <- list(
  base = list(
    nms = c(
      "is.array",       "is.call",        "is.complex",     "is.data.frame",
      "is.environment", "is.expression",  "is.factor",      "is.language",
      "is.matrix",      "is.na",          "is.name",        "is.nan",
      "is.ordered",     "is.pairlist",    "is.primitive",   "is.raw",
      "is.recursive",   "is.symbol",      "is.table",       "is.unsorted"
    ),
    pattern = "^is\\.",
    sep = "\\.",
    ns = "base"
  ),
  purrr = list(
    nms = grep("^is_", getNamespaceExports("purrr"), value = TRUE),
    pattern = "^is_",
    sep = "_",
    ns = "purrr"
  )
)

chkrs_ <- pkg %>%
  lapply(function(.) make_vld_chkrs(.$nms, .$pattern, .$sep, .$ns))
chkrs  <- purrr::flatten(chkrs_)

for (nm in names(chkrs))
  assign(nm, chkrs[[nm]])

#' @rawNamespace exportPattern("^vld_.*$")
NULL

# Documentation -----------------------------------------------------------

# Aliases, "Usage"

nms <- lapply(c(bare = "^vld_bare", scalar = "^vld_scalar"),
              grep, x = names(chkrs_$purrr), value = TRUE)
nms$misc <- c(names(chkrs_$base), paste0("vld_", c("empty", "formula")))
nms$type <- setdiff(names(chkrs_$purrr), unlist(nms))
nms <- lapply(nms, function(.) .[order(tolower(.))])

# "See Also" (required, because @family would overwrite our custom "See Also")

link_code  <- "\\code{\\link{%s}}"
link_extfn <- "\\code{\\link[%s]{%s}}"
link_purrr <- "\\link[purrr:%s-predicates]{%s predicates} (\\pkg{purrr})"

prefix_with <- function(x, text) {
  stats::setNames(paste(text, x), names(x)) %>% as.list()
}

predicates <- list(
  misc = sprintf(link_extfn, "base", pkg$base$nms) %>%
    c(sprintf(link_extfn, "purrr", c("is_empty", "is_formula"))) %>%
    paste(collapse = ", "),
  bare   = sprintf(link_purrr, "bare-type", "Bare type"),
  scalar = sprintf(link_purrr, "scalar-type", "Scalar type"),
  type   = sprintf(link_purrr, "type", "Type")
) %>%
  prefix_with("Corresponding predicates:")

other <- c(
  "\\code{\\link{globalize}()} recovers the underlying check formula of global",
  "scope.\n\n",
  "The documentation for \\code{\\link{strictly}()} explains the notion of",
  "\\dQuote{scope} in the context of check formulae."
) %>%
  paste(collapse = " ")

doc_nms <- c("misc", "bare-type", "scalar-type", "type")
family <- doc_nms %>%
  stats::setNames(paste(., "checkers", sep = "-"), .) %>%
  lapply(function(nm) {
    other <- unname(.[. != nm])
    paste(sprintf(link_code, other), collapse = ", ")
  }) %>%
  prefix_with("Other checkers:")

ref <- Map(function(p, f) c(p, other, f), predicates, family)

#' Miscellaneous checkers
#'
#' These functions make check formulae of local scope based on the
#' correspondingly named \pkg{base} R predicates \code{is.*()} (e.g.,
#' \code{vld_data_frame()} corresponds to the predicate
#' \code{\link[base]{is.data.frame}()}), with the exception that
#' \code{vld_empty()}, \code{vld_formula()} are based on the \pkg{purrr}
#' predicates \code{\link[purrr]{is_empty}()},
#' \code{\link[purrr]{is_formula}()}.
#'
#' @evalRd rd_alias(nms$misc)
#' @evalRd rd_usage(nms$misc)
#' @param \dots One-sided formulae that specify the expressions to check.
#' @return Check formula of local scope.
#' @details Each function \code{vld_*()} is a function of class
#'   \code{"check_maker"} generated by \code{\link{localize}()}.
#' @evalRd rd_seealso(ref$misc)
#' @examples
#' \dontrun{
#'
#' f <- function(x, y) "Pass"
#'
#' # Impose the condition that x is a formula
#' g <- strictly(f, vld_formula(~ x))
#' g(z ~ a + b, 0)  # "Pass"
#' g(0, 0)          # Error: "Not formula: x"
#'
#' # Impose the condition that x and y are disjoint (assuming they are vectors)
#' h <- strictly(f, vld_empty(~ intersect(x, y)))
#' h(letters[1:3], letters[4:5])  # "Pass"
#' h(letters[1:3], letters[3:5])  # Error: "Not empty: intersect(x, y)"
#' }
#' @name misc-checkers
NULL

#' Type checkers
#'
#' These functions make check formulae of local scope based on the
#' correspondingly named \link[purrr:type-predicates]{type predicate} from the
#' \pkg{purrr} package. For example, \code{vld_atomic()} creates check formulae
#' (of local scope) for the \pkg{purrr} predicate function
#' \code{\link[purrr]{is_atomic}()}.
#'
#' @evalRd rd_alias(nms$type)
#' @evalRd rd_usage(nms$type)
#' @param \dots One-sided formulae that specify the expressions to check.
#' @inherit misc-checkers
#' @evalRd rd_seealso(ref$type)
#' @examples
#' \dontrun{
#'
#' f <- function(x, y) "Pass"
#'
#' # Impose a check on x: ensure it's of type "logical"
#' f_strict <- strictly(f, vld_logical(~ x))
#' f_strict(TRUE, 0)  # "Pass"
#' f_strict(1, 0)     # Error: "Not logical: x"
#'
#' # To impose the same check on all arguments, apply globalize()
#' f_stricter <- strictly(f, globalize(vld_logical))
#' f_stricter(TRUE, FALSE)  # "Pass"
#' f_stricter(TRUE, 0)      # Error: "Not logical: y"
#' f_stricter(1, 0)         # Errors: "Not logical: x", "Not logical: y"
#' }
#' @name type-checkers
NULL

#' Bare type checkers
#'
#' These functions make check formulae of local scope based on the
#' correspondingly named \link[purrr:bare-type-predicates]{bare type predicate}
#' from the \pkg{purrr} package. For example, \code{vld_bare_atomic()} creates
#' check formulae (of local scope) for the \pkg{purrr} predicate function
#' \code{\link[purrr]{is_bare_atomic}()}.
#'
#' @evalRd rd_alias(nms$bare)
#' @evalRd rd_usage(nms$bare)
#' @param \dots One-sided formulae that specify the expressions to check.
#' @inherit misc-checkers
#' @evalRd rd_seealso(ref$bare)
#' @examples
#' \dontrun{
#'
#' f <- function(x, y) "Pass"
#'
#' # Impose a check on x: ensure it's a bare logical object (i.e., has no class)
#' f_strict <- strictly(f, vld_bare_logical(~ x))
#' x <- structure(TRUE, class = "boolean")
#' f_strict(TRUE, 0)  # "Pass"
#' f_strict(x, 0)     # Error: "Not bare logical: x"
#'
#' # To impose the same check on all arguments, apply globalize()
#' f_stricter <- strictly(f, globalize(vld_bare_logical))
#' f_stricter(TRUE, FALSE)  # "Pass"
#' f_stricter(TRUE, 0)      # Error: "Not bare logical: y"
#' f_stricter(x, 0)         # Errors: "Not bare logical: x", "Not bare logical: y"
#' }
#' @name bare-type-checkers
NULL

#' Scalar type checkers
#'
#' These functions make check formulae of local scope based on the
#' correspondingly named \link[purrr:scalar-type-predicates]{scalar type
#' predicate} from the \pkg{purrr} package. For example,
#' \code{vld_scalar_atomic()} creates check formulae (of local scope) for the
#' \pkg{purrr} predicate function \code{\link[purrr]{is_scalar_atomic}()}.
#'
#' @evalRd rd_alias(nms$scalar)
#' @evalRd rd_usage(nms$scalar)
#' @param \dots One-sided formulae that specify the expressions to check.
#' @inherit misc-checkers
#' @evalRd rd_seealso(ref$scalar)
#' @examples
#' \dontrun{
#'
#' f <- function(x, y) "Pass"
#'
#' # Impose a check on x: ensure it's a scalar logical vector
#' f_strict <- strictly(f, vld_scalar_logical(~ x))
#' f_strict(TRUE, 0)           # "Pass"
#' f_strict(c(TRUE, TRUE), 0)  # Error: "Not scalar logical: x"
#'
#' # To impose the same check on all arguments, apply globalize()
#' f_stricter <- strictly(f, globalize(vld_scalar_logical))
#' f_stricter(TRUE, FALSE)    # "Pass"
#' f_stricter(TRUE, 0)        # Error: "Not scalar logical: y"
#' f_stricter(logical(0), 0)  # Errors: "Not scalar logical: x", "Not scalar logical: y"
#' }
#' @name scalar-type-checkers
NULL
